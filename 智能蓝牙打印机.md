# 智能蓝牙打印机

[‍‍‬‍‌‌﻿﻿‌﻿‍﻿‬‬‬⁠⁠‬﻿‬⁠⁠⁠STM32版本固件烧录-快速玩起来 - 飞书云文档](https://x509p6c8to.feishu.cn/docx/WW89dikVbok6oPxE1Kzco0yVnPg)

## CUBEMX配置

### RCC

####选择外部高速时钟

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503210558950.png" alt="image-20250503210558950" style="zoom:50%;" />

####设置Clock

HCLK 72MHZ

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503210702672.png" alt="image-20250503210702672" style="zoom:50%;" />

#### 设置debug timebase source

- 借助SWD将代码烧录到芯片
- **其他定时器（如 TIMx）**：STM32 微控制器有多个通用定时器（TIM）等 。在使用实时操作系统（RTOS）时，为避免与 RTOS 对 SysTick 的使用冲突，常选用其他定时器作为时间基准源，可实现不同时间基准独立管理，减少潜在干扰，但配置相对复杂。

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503211347446.png" alt="image-20250503211347446" style="zoom:50%;" />

----

### GPIO

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503233903328.png" alt="image-20250503233903328" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503233916204.png" alt="image-20250503233916204" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503233928218.png" alt="image-20250503233928218" style="zoom:50%;" />

### ADC

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503234428449.png" alt="image-20250503234428449" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503234440933.png" alt="image-20250503234440933" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503234455928.png" alt="image-20250503234455928" style="zoom:50%;" />

### TIM

1us计时

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503234609425.png" alt="image-20250503234609425" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503234720199.png" alt="image-20250503234720199" style="zoom:50%;" />

### 设置SPI和IO

- 半双工主机模式

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250503234929748.png" alt="image-20250503234929748" style="zoom:50%;" />

### 设置串口模式与IO

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250504000042131.png" alt="image-20250504000042131" style="zoom:50%;" />

### 设置支持RTOS

？为什么3072

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250504000327491.png" alt="image-20250504000327491" style="zoom:50%;" />

## 软件模块

### 电量+温度ADC

先把每个模块的代码理解好，一个一个的复制进去，最后调试

我觉得这里可以跟老师提一下

![image-20250505141648502](C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250505141648502.png)

ADC检测的是R2两端的电压

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250505152355082.png" alt="image-20250505152355082" style="zoom:50%;" />

```h
#ifndef __EM_ADC_H__
#define __EM_ADC_H__

#include <main.h>

void adc_init(void);

int get_adc_volts(void);

void em_adc_test(void);

float get_adc_temperatrue(void);

#endif
```



```c
#include "em_config.h"
#include "math.h"

extern ADC_HandleTypeDef hadc1;

#define ADC_READ_TIME 10
#define EPISON 1e-7

uint32_t ADC_Value[2];

/*开启adc*/
void adc_init() {
        HAL_ADC_Start(&hadc1);
		//轮询等待ADC是否转换完成
        HAL_ADC_PollForConversion(&hadc1,1000);        
}

/*获取数组,去掉最大值和最小值,求得剩下数的平均值*/
uint32_t adc_alg_handle(uint32_t *adc, int size) {
    uint32_t sum = 0;
    uint32_t min_val = adc[0];
    uint32_t max_val = adc[0];

    for (int i = 0; i < size; i++) {
        if (adc[i] < min_val) {
            min_val = adc[i];
        }
        else if (adc[i] > max_val) {
            max_val = adc[i];
        }
        sum += adc[i];
    }
    sum = sum - (min_val + max_val);
    uint32_t avg_val = sum / (size - 2);
    return avg_val;
}


/**
 * @brief 获取ADC引脚电压值，可根据需要加入滤波算法
 * 
 * @return int 
 */
int get_adc_volts()
{
  float data = 0;//修改成浮点数
  uint32_t adc1[ADC_READ_TIME];//存储通道0的采样数据
  uint32_t adc2[ADC_READ_TIME];//存储通道1的采样数据
  
  for (int sample_ptr = 0; sample_ptr < ADC_READ_TIME; sample_ptr++)
  {
                //由于上面设置的ADC是间断模式+扫描模式，所以每采集一次，需要执行一次HAL_ADC_Start
                HAL_ADC_Start(&hadc1);//这里开启一次即可，自动按顺序转换
                if (HAL_ADC_PollForConversion(&hadc1, 100) == HAL_OK)
                {
                		//使用数组存储每次ADC转运的数据
                         adc1[sample_ptr] = HAL_ADC_GetValue(&hadc1);
                }
                //HAL_ADC_Start(&hadc1);
                if (HAL_ADC_PollForConversion(&hadc1, 100) == HAL_OK)
                {
                         adc2[sample_ptr] = HAL_ADC_GetValue(&hadc1);
                }
                HAL_ADC_Stop(&hadc1);
  }
  ADC_Value[0] = adc_alg_handle(adc1, ADC_READ_TIME);//获取平均值
  ADC_Value[1] = adc_alg_handle(adc2, ADC_READ_TIME);

  //通道0--电量检测 通道1--温度检测
  printf(" ADC channel0 end value = ->%1.3fV \r\n", ADC_Value[0] * 3.3f / 4096);
  printf(" ADC channel1 end value = ->%1.3fV \r\n", ADC_Value[1] * 3.3f / 4096);
  data = ADC_Value[0] * 3.3f / 4096;

  HAL_ADC_Stop(&hadc1);
  return data;
}

/*
//将输入值 x 从输入范围 [in_min, in_max] 线性映射到输出范围 [out_min, out_max]
static long map(long x, long in_min, long in_max, long out_min, long out_max) {
    const long dividend = out_max - out_min;
    const long divisor = in_max - in_min;
    const long delta = x - in_min;
    if(divisor == 0){
        return -1; //AVR returns -1, SAM returns 0
    }
    return (delta * dividend + (divisor / 2)) / divisor + out_min;
}

//get_adc_volts()*2  分压之后×2
void read_battery()
{
    //这里我们认为电压在3.3V为0%电量，4.2V为100%电量，进行转换
    get_device_state()->battery = map(get_adc_volts()*2000,3300,4200,0,100);
    if(get_device_state()->battery > 100)
     get_device_state()->battery = 100;
    printf("battery = %d\n",get_device_state()->battery);
}
*/

/**
 * @brief 阻值转换温度，ADC检测的是R2两端的电压
 *
 * @param Rt 热敏电阻阻值
 * @return float 返回摄氏度温度
 */
float em_temp_calculate(float Rt)
{
    float Rp = 30000; // 30k
    float T2 = 273.15 + 25;
    float Bx = 3950; // B值
    float Ka = 273.15;
    float temp = 0.0f;

    temp = 1 / (log(Rt / Rp) / Bx + 1 / T2) - Ka + 0.5;
    return temp;
}

/**
 * @brief Get the adc temperatrue object
 * 
 * @return float 
 */
float get_adc_temperatrue(){
  float temp = 0.0f;
  float Rt=0;
  float vol=0;
  //ADC转换为电压 vol=AD/4096*VCC
  vol=(float)ADC_Value[1]*3.3f/4096;
	printf("ADC temperatrue analog value = %f\n",vol);
  //电压转换为阻值 原理图为10k 1%精度  vol/VCC=Rt/(R+Rt)  vol/3.3=Rt/(10000+Rt)
  Rt=(vol*10000)/(3.3-vol);
	printf("ADC temperatrue Rt = %f\n",Rt);
  temp = em_temp_calculate(Rt);
  return temp;
}

void em_adc_test(){
  float Rt=0;
  float vol=3.0f;
  Rt=(vol*10000)/(3.3-vol);
  printf("Rt = %f\n",Rt);
  
  Rt = 60000; //60k 10°C
  float temp = 0.0f;
  temp = em_temp_calculate(Rt);
  printf("temp = %f\n",temp);

  if(temp >= EPISON){
      printf("正\n");
  }else{
      printf("负\n");
  }
}
```



### 串口重定向

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250505153402688.png" alt="image-20250505153402688" style="zoom:50%;" />

```c
//重写 int fputc(int ch, FILE *f)
//使用UART发送数据，并且一直等待直到发送完成
PUTCHAR_PROTOTYPE
{
  /* Place your implementation of fputc here */
  /* e.g. write a character to the EVAL_COM1 and Loop until the end of transmission */
  HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);
 
  return ch;
}
```

### 消息队列

写入是随机的，更使用中断，能更快处理

```h
#ifndef _EM_QUEUE_H_
#define _EM_QUEUE_H_

#include "em_config.h"

//一行最大byte
#define MAX_ONELINE_BYTE 48
//最大行数
#define MAX_LINE 275

typedef struct{
    uint8_t buffer[MAX_ONELINE_BYTE];//缓存区结构体
}ble_rx_buffer_t;

typedef struct{
    ble_rx_buffer_t printer_buffer[MAX_LINE];
    uint32_t r_index;
    uint32_t w_index;
    uint32_t left_line;
}ble_rx_t;//管理且记录对这个缓存区的处理

void write_to_printbuffer(uint8_t *pdata,size_t length);

uint32_t get_ble_rx_leftline(void);

void clean_printbuffer(void);

uint8_t * read_to_printer(void);

void init_queue(void);

#endif



```



```c
#include "em_queue.h"
#include "semphr.h"

ble_rx_t g_ble_rx;//使用这个结构体管理缓存区

SemaphoreHandle_t xHandler = NULL;//信号量

void init_queue()
{
		clean_printbuffer();//情空缓存区
    xHandler = xSemaphoreCreateMutex();//创建互斥量
}

/**
 * @brief 写入一行数据
 *
 * @param pdata
 * @param length
 */
void write_to_printbuffer(uint8_t *pdata, size_t length)
{
		static BaseType_t xHigherPriorityTaskWoken;//用于检测是否有更高优先级的任务被唤醒
    if (length == 0)
        return;
    if (g_ble_rx.left_line >= MAX_LINE)//超过最大行数进行返回
        return;
    if (length > MAX_ONELINE_BYTE)//每行写入不能超过最大48Byte
        length = MAX_ONELINE_BYTE;
    // 查看是否可以获得信号量，如果信号量不可用，则用10个时钟滴答来查看信号量是否可用
    if (xSemaphoreTakeFromISR(xHandler, &xHigherPriorityTaskWoken) == pdPASS)
    {
    //这是 C 标准库中的内存复制函数，用于将一段内存的数据复制到另一段内存
    //目标内存地址，复制数据，长度
        memcpy(&g_ble_rx.printer_buffer[g_ble_rx.w_index], pdata, length);
        g_ble_rx.w_index++;//写入索引加1
        g_ble_rx.left_line++;//写入行数+1
        if (g_ble_rx.w_index >= MAX_LINE)
            g_ble_rx.w_index = 0;//超过则清0，实现循环写入
        if (g_ble_rx.left_line >= MAX_LINE)
            g_ble_rx.left_line = MAX_LINE;//写入行数到了，就不让再加
        xSemaphoreGiveFromISR(xHandler,&xHigherPriorityTaskWoken);//释放信号量
    }
		if(xHigherPriorityTaskWoken == pdTRUE){
			// 如果有更高优先级的任务需要唤醒，则进行任务切换
			portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
		}
}

/**
 * @brief 读取一行数据
 *
 * @return uint8_t*
 */
uint8_t *read_to_printer()
{
    uint32_t index = 0;
    // 查看是否可以获得信号量，如果信号量不可用，则用10个时钟滴答来查看信号量是否可用
    if (xSemaphoreTake(xHandler, (portTickType)10) == pdPASS)
    {
        if (g_ble_rx.left_line > 0)
        {
            g_ble_rx.left_line--;//读出减少可用行数
            index = g_ble_rx.r_index;//获取read索引
            g_ble_rx.r_index++;//增加已读index
            if (g_ble_rx.r_index >= MAX_LINE)
                g_ble_rx.r_index = 0;//读完所有行归0
            xSemaphoreGive(xHandler);//释放信号量
            return g_ble_rx.printer_buffer[index].buffer;//返回读的哪一行的结构体缓存区
        }
        xSemaphoreGive(xHandler);//如果没有数据可读，take了，也要give
        return NULL;
    }else
        return NULL;
}

/**
 * @brief 清空接收缓存
 *
 */
void clean_printbuffer()
{
    g_ble_rx.w_index = 0;
    g_ble_rx.r_index = 0;
    g_ble_rx.left_line = 0;
}

uint32_t get_ble_rx_leftline()
{
    return g_ble_rx.left_line;
}
```

### 设备状态

```h
#ifndef _EM_DEVICE_H_
#define _EM_DEVICE_H_

#include "em_config.h"

typedef enum{
    PRINTER_STATUS_INIT = 0,//初始状态
    PRINTER_STATUS_START,//已经开始启动
    PRINTER_STATUS_WORKING,//正在执行打印任务
    PRINTER_STATUS_FINISH,//已经完成当前的打印任务，处于空闲状态
}printer_state_e;//打印机状态

typedef enum{
    PAPER_STATUS_NORMAL = 0,//纸张充足--正常
    PAPER_STATUS_LACK,//纸张不足或者已经用完--等待
}paper_state_e;//打印机纸张状态，

typedef struct
{
    uint8_t battery;//电量
    uint8_t temperature;//温度
    paper_state_e paper_state;//缺纸状态
    printer_state_e printer_state; //打印状态
	  bool read_ble_finish;//蓝牙接收数据完成状态
}device_state_t;

void init_device_state(void);

device_state_t * get_device_state(void);

void set_read_ble_finish(bool finish);

void set_device_paper_status(paper_state_e status);

#endif


```

```c
#include "em_device.h"

device_state_t g_device_state;

device_state_t * get_device_state(){
    return &g_device_state;//返回状态结构体
}

void set_device_paper_status(paper_state_e status){//设置当前纸张状态
    g_device_state.paper_state = status;
}

void set_read_ble_finish(bool finish){//设置蓝牙接收数据状态
    g_device_state.read_ble_finish = finish;
}

void init_device_state(){//初始化状态
    memset(&g_device_state,0,sizeof(device_state_t));//将g_device_state全部置0
    g_device_state.printer_state = PRINTER_STATUS_INIT;
    g_device_state.battery = 100;
    g_device_state.temperature = 30;
    g_device_state.paper_state = PAPER_STATUS_NORMAL;
		g_device_state.read_ble_finish = false;
}



```

### 配置模块

使用定时器1做us的延时函数

宏定义每个引脚，进行后续对它们的判断，其实在stm32里面不定义也行，因为和esp不一样

先让它运行出来，再统一改编吧

```c
#ifndef _EM_CONFIG_H_
#define _EM_CONFIG_H_

#include "stm32f1xx_hal.h"

#include "FreeRTOS.h"
#include "cmsis_os.h"

#include <string.h>
#include <stdbool.h>
#include <stdio.h>

#define _FREERTOS_OPEN_ 

#define SERVICE_UUID "4fafc201-1fb5-459e-8fcc-c5c9c331914b"         // 自定义打印服务UUID

#define CHARACTERISTIC_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"  // 自定义打印特征UUID

#define BLE_NAME "Mini-Printer"

//接收完成所有数据才开始打印
#define START_PRINTER_WHEN_FINISH_RAED 1

//按键引脚
//34 35 36 39仅可以作为输入INPUT,不支持INPUT_PULLUP
#define PIN_KEY 5
//缺纸检测引脚
#define PIN_PAPER 35
//电量相关引脚
#define PIN_BATTERY_ADC 34
#define PIN_ADC_EN 4
//set the resolution to 12 bits (0-4096)
#define BATTERY_ADC_BIT 12
//热敏电阻
#define PIN_TEMPERATRUE 36
//蜂鸣器
#define PIN_BEEP 18
#define PIN_LED 18

//V2 电机引脚
// #define PIN_MOTOR_AP 19
// #define PIN_MOTOR_AM 21
// #define PIN_MOTOR_BP 22
// #define PIN_MOTOR_BM 23
//V3 电机引脚
#define PIN_MOTOR_AP 23
#define PIN_MOTOR_AM 22
#define PIN_MOTOR_BP 21
#define PIN_MOTOR_BM 19

//打印头数据引脚
#define PIN_LAT 12
#define PIN_SCK 2
#define PIN_SDA 15

//拆机 V2
// #define PIN_STB1 32
// #define PIN_STB2 33
// #define PIN_STB3 25
// #define PIN_STB4 26
// #define PIN_STB5 27
// #define PIN_STB6 14

//原厂 V3
#define PIN_STB1 26
#define PIN_STB2 27
#define PIN_STB3 14
#define PIN_STB4 32
#define PIN_STB5 33
#define PIN_STB6 25

//拆机 V2
// #define PIN_STB1 14
// #define PIN_STB2 27
// #define PIN_STB3 26
// #define PIN_STB4 25
// #define PIN_STB5 33
// #define PIN_STB6 32
//打印头电源升压控制引脚
#define PIN_VHEN 17

#ifdef _FREERTOS_OPEN_
// #define MOTOR_WATI_TIME 4   //ms
// #define PRINT_TIME 2        //ms
// #define PRINT_END_TIME 2  //ms
#define PRINT_TIME 2600         //打印加热时间
#define PRINT_END_TIME 200      //冷却时间
#define MOTOR_WATI_TIME 4000    //电机一步时间
#define LAT_TIME 1              //数据锁存时间
#else
//打印头电机参数
#define PRINT_TIME 1700         //打印加热时间
#define PRINT_END_TIME 200      //冷却时间
#define MOTOR_WATI_TIME 4000    //电机一步时间
#define LAT_TIME 1              //数据锁存时间
#endif


#include "tim.h"
#define DLY_TIM_Handle (&htim1)  // Timer handle
#define hal_delay_us(nus) do { \
    __HAL_TIM_SET_COUNTER(DLY_TIM_Handle, 0); \
    __HAL_TIM_ENABLE(DLY_TIM_Handle); \
    while (__HAL_TIM_GET_COUNTER(DLY_TIM_Handle) < (nus)); \
    __HAL_TIM_DISABLE(DLY_TIM_Handle); \
} while(0)


#ifdef _FREERTOS_OPEN_
#define us_delay(ms) hal_delay_us(ms)
//#define us_delay(ms) delayMicroseconds(ms)
#else
#define us_delay(ms) delayMicroseconds(ms)
#endif

#define LOW               0x0
#define HIGH              0x1

#endif

```

### 电机驱动模块

INA--IN4---PB6

INA- IN

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250505185459720.png" alt="image-20250505185459720" style="zoom:50%;" />

```c
#include "em_motor.h"
#include "main.h"

static void digitalWrite(int pin,int PinState){
	if(pin == PIN_MOTOR_AP){
		HAL_GPIO_WritePin(GPIOB,MOTOR_IN1_Pin,(GPIO_PinState)PinState);
	}else if(pin == PIN_MOTOR_AM){
		HAL_GPIO_WritePin(GPIOB,MOROT_IN2_Pin,(GPIO_PinState)PinState);
	}else if(pin == PIN_MOTOR_BP){
		HAL_GPIO_WritePin(GPIOB,MOTOR_IN3_Pin,(GPIO_PinState)PinState);
	}else if(pin == PIN_MOTOR_BM){
		HAL_GPIO_WritePin(GPIOB,MOTOR_IN4_Pin,(GPIO_PinState)PinState);
	}
}

/*
step  A  B  A- B-
      AN BN AP BP
1     1  0  0  1
2     0  0  0  1
3     0  0  1  1
4     0  0  1  0	//前四行用于前进
5     0  1  1  0	//等待延时打印
6     0  1  0  0
7     1  1  0  0
8     1  0  0  0
4step 行进一点行
对应PIN
A- A B- B
0  1 1  0
0  0 1  0
1  0 1  0
1  0 0  0
1  0 0  1
0  0 0  1
0  1 0  1
0  1 0  0
*/
uint8_t motor_pos = 0;

uint8_t motor_table[8][4] =
    {
        {0, 1, 1, 0},
        {0, 0, 1, 0},
        {1, 0, 1, 0},
        {1, 0, 0, 0},
        {1, 0, 0, 1},
        {0, 0, 0, 1},
        {0, 1, 0, 1},
        {0, 1, 0, 0}};

osTimerId myMotorTimerHandle;//freertos定时器句柄--控制步进电机的周期性旋转

//定时器回调函数--旋转一步
void read_motor_timer_callbackfun(void const * argument)
{
    // Serial.println("timer_motor is running...");
    digitalWrite(PIN_MOTOR_AP, motor_table[motor_pos][0]);
    digitalWrite(PIN_MOTOR_AM, motor_table[motor_pos][1]);
    digitalWrite(PIN_MOTOR_BP, motor_table[motor_pos][2]);
    digitalWrite(PIN_MOTOR_BM, motor_table[motor_pos][3]);
    motor_pos++;
    if (motor_pos >= 8)
    {
        motor_pos = 0;
    }
}	

void motor_start()
{
	//创建一个周期性定时器（osTimerPeriodic），绑定回调函数 read_motor_timer_callbackfun。
//定时器触发时，自动调用 read_motor_timer_callbackfun，驱动电机旋转一步。
	if(myMotorTimerHandle == NULL){
		//定义定时器
		osTimerDef(myMotorTimer, read_motor_timer_callbackfun);
		myMotorTimerHandle = osTimerCreate(osTimer(myMotorTimer), osTimerPeriodic, NULL);
	}
	osTimerStart(myMotorTimerHandle,2); //启动定时器，周期2ms
}

void motor_stop()//暂停
{
    digitalWrite(PIN_MOTOR_AP, 0);
    digitalWrite(PIN_MOTOR_AM, 0);
    digitalWrite(PIN_MOTOR_BP, 0);
    digitalWrite(PIN_MOTOR_BM, 0);
		if(myMotorTimerHandle != NULL)
			osTimerStop(myMotorTimerHandle);
}

void motor_run()//前进一步
{
    digitalWrite(PIN_MOTOR_AP, motor_table[motor_pos][0]);
    digitalWrite(PIN_MOTOR_AM, motor_table[motor_pos][1]);
    digitalWrite(PIN_MOTOR_BP, motor_table[motor_pos][2]);
    digitalWrite(PIN_MOTOR_BM, motor_table[motor_pos][3]);
    motor_pos++;
    if (motor_pos >= 8)
    {
        motor_pos = 0;
    }
}

void motor_run_step(uint32_t steps)//前进指定步数
{
    while (steps)
    {
        digitalWrite(PIN_MOTOR_AP, motor_table[motor_pos][0]);
        digitalWrite(PIN_MOTOR_AM, motor_table[motor_pos][1]);
        digitalWrite(PIN_MOTOR_BP, motor_table[motor_pos][2]);
        digitalWrite(PIN_MOTOR_BM, motor_table[motor_pos][3]);
        motor_pos++;
        if (motor_pos >= 8)
        {
            motor_pos = 0;
        }
        us_delay(MOTOR_WATI_TIME);
        steps--;
    }
}

void init_motor()//初始化输入
{
    digitalWrite(PIN_MOTOR_AP, 0);
    digitalWrite(PIN_MOTOR_AM, 0);
    digitalWrite(PIN_MOTOR_BP, 0);
    digitalWrite(PIN_MOTOR_BM, 0);
}


```

h

```h
#ifndef _EM_MOTOR_H_
#define _EM_MOTOR_H_

#include "em_config.h"

void motor_run_step(uint32_t steps);
void motor_start(void);
void motor_stop(void);
void init_motor(void);
void motor_run(void);

#endif
```

### SPI模块

```c
#include "em_spi.h"

//static const int spiClk = 1000000; // 1 MHz

//SPIClass hspi  = SPIClass(HSPI);
//SPISettings printerSPISettings = SPISettings(1000000, SPI_MSBFIRST, SPI_MODE0);
//指针传递，数据缓存区，数据长度
void spiCommand(uint8_t *data_buffer, uint8_t data_len)
{
//    hspi.beginTransaction(printerSPISettings);
//    hspi.transfer(data_buffer, data_len);
//    hspi.endTransaction();
		HAL_SPI_Transmit(&hspi1, data_buffer, data_len, 0xFFFF);
}

void init_spi()
{
//    hspi.begin(PIN_SCK, -1, PIN_SDA, -1); // SCLK, MISO, MOSI, SS
//    hspi.setFrequency(2000000);
}
```

h

```h
#ifndef _EM_SPI_H_
#define _EM_SPI_H_

#include "em_config.h"
#include <SPI.h>

void spiCommand(uint8_t *data_buffer, uint8_t data_len);

void init_spi(void);

#endif
```

### 软件定时器

```c
#include "em_timer.h"
#include "em_config.h"


bool read_state_timeout = false;
bool printer_timeout = false;

osTimerId myStateTimerHandle;//定时器句柄
osTimerId myTimeoutTimerHandle;//定时器句柄

//读取状态定时器回调函数
/* read_state_timer_callbackfun function */
void read_state_timer_callbackfun(void const * argument)
{
  /* USER CODE BEGIN read_state_timer_callbackfun */
  printf("read_state now...\r\n");
  read_state_timeout = true;//回调进行中
  /* USER CODE END read_state_timer_callbackfun */
}
//初始化定时器
void init_timer(){
	osTimerDef(myStateTimer, read_state_timer_callbackfun);
  myStateTimerHandle = osTimerCreate(osTimer(myStateTimer), osTimerPeriodic, NULL);
	osTimerStart(myStateTimerHandle,10000);//每隔10s运行一次
}

bool get_state_timeout(){//获取状态检测超时标志
    return read_state_timeout;
}

void clean_state_timeout(){//清除状态检测超时标志
    read_state_timeout = false;
}

//打印超时定时器回调函数
/* read_state_timer_callbackfun function */
void read_timeout_timer_callbackfun(void const * argument)
{
  /* USER CODE BEGIN read_state_timer_callbackfun */
  printf("触发打印超时错误...\r\n");
  printer_timeout = true;
  /* USER CODE END read_state_timer_callbackfun */
}

bool get_printer_timeout_status(){//或许打印超时标志
  return printer_timeout;
}

void open_printer_timeout_timer(){//定义定时器，每20ms触发一次
  printer_timeout = false;
	osTimerDef(myTimeoutTimer, read_timeout_timer_callbackfun);
  myTimeoutTimerHandle = osTimerCreate(osTimer(myTimeoutTimer), osTimerOnce, NULL);
	osTimerStart(myTimeoutTimerHandle,20000);    
}

void close_printer_timeout_timer(){//关闭打印超时定时器
	osTimerDelete(myTimeoutTimerHandle);
}
```

```h
#ifndef _EM_TIMER_H_
#define _EM_TIMER_H_

#include "em_config.h"

/**
 * @brief 初始化Timer
 * 
 */
void init_timer(void);

/**
 * @brief Get the state timeout objectd
 * 
 * @return true 
 * @return false 
 */
bool get_state_timeout(void);

/**
 * @brief 
 * 
 */
void clean_state_timeout(void);

/**
 * @brief 开启打印超时计时器
 * 
 */
void open_printer_timeout_timer(void);

/**
 * @brief 关闭打印超时计时器
 * 
 */
void close_printer_timeout_timer(void);

/**
 * @brief Get the printer timeout status object
 * 
 * @return true 
 * @return false 
 */
bool get_printer_timeout_status(void);

#endif
```

### hal层接口

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250505203023113.png" alt="image-20250505203023113" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250505201024428.png" alt="image-20250505201024428" style="zoom:50%;" />

```c
#include "em_hal.h"
#include "em_adc.h"
#include "main.h"

int freq = 2000;    //设置频率2000kHz
int channel = 0;    //通道号，取值0 ~ 15
int resolution = 8; //分辨率，取值0~20，占空比duty最大取值为2^resolution-1

bool need_report = false;


#define EPISON 1e-7

static int digitalRead(int pin){
	return HAL_GPIO_ReadPin(VHINT_GPIO_Port,VHINT_Pin);//读取缺纸口GPIO状态
}

static void digitalWrite(int pin,int PinState){//设置LED口
	HAL_GPIO_WritePin(GPIOB,LED_Pin,(GPIO_PinState)PinState);
}

static long map(long x, long in_min, long in_max, long out_min, long out_max) {
    const long dividend = out_max - out_min;
    const long divisor = in_max - in_min;
    const long delta = x - in_min;
    if(divisor == 0){
        return -1; //AVR returns -1, SAM returns 0
    }
    return (delta * dividend + (divisor / 2)) / divisor + out_min;
}

void read_battery()
{
	//设置状态结构体里面的电量
		get_device_state()->battery = map(get_adc_volts()*2000,3300,4200,0,100);
	  if(get_device_state()->battery > 100)
      get_device_state()->battery = 100;
    printf("battery = %d\n",get_device_state()->battery);
}

void read_temperature()
{
    float temperatrue = get_adc_temperatrue();
    printf("temperature = %f\n",temperatrue);
    if(temperatrue >= EPISON){//判断获取的温度值是不是有效
        get_device_state()->temperature = temperatrue;
    }else{
        get_device_state()->temperature = 0;
    }
}

void run_beep(beep_type_e type){

}

void run_led(led_type_e type){//根据传入类型设置LED的状态
    switch (type)
    {
    case LED_CONNECT:
        digitalWrite(PIN_LED, 0);
        break;
		case LED_DISCONNECT:
				digitalWrite(PIN_LED, 1);
        break;
    case LED_WARN:
        digitalWrite(PIN_LED, 0);
        vTaskDelay(200);
        digitalWrite(PIN_LED, 1);
        vTaskDelay(200);
        digitalWrite(PIN_LED, 0);
        vTaskDelay(200);
        digitalWrite(PIN_LED, 1);
        vTaskDelay(200);
        digitalWrite(PIN_LED, 0);
        break;
    case LED_PRINTER_START:
				digitalWrite(PIN_LED, 1);
				vTaskDelay(200);
        digitalWrite(PIN_LED, 0);
        vTaskDelay(200);
        break;
		case LED_BLE_INIT:
				digitalWrite(PIN_LED, 0);
        vTaskDelay(10);
        digitalWrite(PIN_LED, 1);
    default:
        break;
    }
}

//设置GPIO外部中断回调函数
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	if(GPIO_Pin & GPIO_PIN_8)//判断第8位是否为1触发的中断
	{
		printf("--");
	    need_report = true;//设置需要上报
	    set_device_paper_status(PAPER_STATUS_LACK);//设置缺纸状态
	}
}

//去读缺纸检测IO值--打印读取的状态
void read_paper_statue()
{
    if(digitalRead(PIN_PAPER) == PAPER_STATUS_NORMAL){
        get_device_state()->paper_state = PAPER_STATUS_NORMAL;
    }else{
        get_device_state()->paper_state = PAPER_STATUS_LACK;
    }
    printf("paper_state = %d\n",get_device_state()->paper_state);
}

//返回需要上报状态，并且重置false
bool read_paper_irq_need_report_status()
{
    if (need_report)
    {
        need_report = false;
        return true;
    }
    else
        return false;
}

//调用读取这三个状态
void read_all_hal()
{
    read_battery();
    read_temperature();
    read_paper_statue();
}

//关闭LED灯
void init_hal()
{
    //缺纸IO初始化
    // pinMode(PIN_PAPER, INPUT);
    // attachInterrupt(PIN_PAPER, paper_isr, RISING);
	
	digitalWrite(PIN_LED, 1);
	

}
```

```h
#ifndef _EM_HAL_H_
#define _EM_HAL_H_

#include "em_config.h"
#include "em_device.h"//引入各类状态设置.h文件

//蜂鸣器设置
typedef enum{
    BEEP_CONNECT = 0,
    BEEP_WARN,
    BEEP_PRINTER_START,
}beep_type_e;

typedef enum{
    LED_CONNECT = 0,//led连接
		LED_DISCONNECT,//失连
    LED_WARN,//警告
    LED_PRINTER_START,//开始打印
		LED_BLE_INIT,//蓝牙初始化
}led_type_e;


void run_beep(beep_type_e type);

void run_led(led_type_e type);

void read_all_hal(void);

void init_hal(void);

bool read_paper_irq_need_report_status(void);


#endif
```

### BLE串口

蓝牙部分我们使用串口2进行数据交互，所以需要重写串口2的处理函数

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250505203802987.png" alt="image-20250505203802987" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250505203833609.png" alt="image-20250505203833609" style="zoom:50%;" />

```c
//重写串口2的接收回调函数
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){
	if(huart->Instance == USART2){
			uart_cmd_handle(aRxBuffer);//处理接受的数据
			//在maic.c中还会开启
			HAL_UART_Receive_IT(&huart2, (uint8_t *)&aRxBuffer, 1);//把接收到的数据放入aRxBuffer
	}
}
```

//输入命令成功后会返回OK	--使用的是USART2-传输蓝牙命令			

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250506213056974.png" alt="image-20250506213056974" style="zoom:50%;" />

- 疑惑为什么这个地方默认true，我觉得应该要改，到时候编译再看吧！！

![image-20250506214652713](C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250506214652713.png)

### 任务

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250507144626873.png" alt="image-20250507144626873" style="zoom:50%;" />

![image-20250507153457790](C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250507153457790.png)

## 烧录

### 安装

typec串口助手，了解调试信息，先测试，玩一下

了解流程图，自己减小规模，再慢慢扩大进行更改

把从画图，设计，下单，等等这些东西理清到底是怎么一回事

[元件/PCB下单流程 | 嘉立创EDA标准版用户指南](https://docs.lceda.cn/cn/PCB/Order-PCB/index.html)

## 梳理

###实现的功能

> 1. ADC-电量检测--ADC
> 2. ADC-温度检测--ADC
> 3. 按键模块--长按，短按，长按释放
> 4. 串口重定向--USART--一个作为串口消息提示-修改fputc函数，
> 5. 消息队列--手机端通过蓝牙发送数据传入串口--再一行一行写入数据缓存区存放在芯片
> 6. 设备状态--设备状态的初始化以及获取
> 7. 配置模块--一些配置参数，宏定义
> 8. 电机驱动模块--设置定时器-隔2ms更新相位-非阻塞--一次走几步--电机驱动开始，结束函数
> 9. SPI模块--将环形缓存区数据发送至打印头
> 10. 软件定时器--创建定时器--间隔10s上报设备状态到手机，打印时如果持续加热20s，需要触发报警
> 11. hal层接口--把设备底层采集到的数据，进行转换，提供给应用层使用。
> 12. BLE串口---修改串口二的接收回调函数，把输入放入蓝牙模块处理
> 13. 任务--task模块
> 14. 打印模块--驱动步进电机，加热，打印初始化，把数据发给打印头，打印方式

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250508190238602.png" alt="image-20250508190238602" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\按键流程图-1746702652377-6.png" style="zoom: 33%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250508185056540.png" alt="image-20250508185056540" style="zoom:80%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\mermaid-diagram-2025-05-08-185836.png" alt="mermaid-diagram-2025-05-08-185836" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250508175033733.png" alt="image-20250508175033733" style="zoom:50%;" />

- 在usart.c中，重写串口2的接收处理函数，将串口中断接收到的数据，传入处理蓝牙从手机接收数据的函数

- 手机通过蓝牙发送数据，蓝牙再发送给串口，放入缓存区：蓝牙模块 → USART2 → `aRxBuffer` → `uart_cmd_handle()`-->em_ble.c
- 在`uart_cmd_handle`函数里，对传入的数据进行分析，收集了48Byte大小的数据后，调用write_to_printbuffer-->em_queue.c ，将数据写入（将发给打印机的）缓存区
- 打印模块，从缓存区读取一行数据（read_to_printer），start_printing_by_queuebuf()中调用这个（read_to_printer）函数获取数据-->em_print.c  可变队列打印
- start_printing_by_queuebuf()中还要调用send_one_line_data(uint8_t *data)，负责将一行数据发送到打印头，并计算加热时间
- 发给打印机--发送一行数据（send_one_line_data(uint8_t *data)）--底层使用SPI通信--PA5-CLK    PA7-DI-连接打印机
- 这个spi只需要发送即可
- start_printing_by_queuebuf()中还要调用move_and_start_std驱动步进电机走纸
- 数组打印，提前准备好所有的数据，队列打印，有则打

总结：

蓝牙-->串口-->环形缓存区-->打印任务-->打印头+步进电机

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\思考-1746701282632-2.png" alt="思考" style="zoom:50%;" />

![](C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\task流程图.png)

### 涉及到的freertos知识

- 任务管理（任务创建，设置vTaskDelay）
- 软件定时器（创建，启动，（重复调用，使用一次），删除）--设备状态上传，打印超时监听
- 二进制信号量--互斥--为了解决多环境任务下对共享资源的（环形缓冲区g_ble_rx）的竞争访问问题
- 中断管理-使用中断API-互斥量-上下文处理
- 资源管理-堆栈大小处理

> 往缓存区写入数据使用中断take give，因为这个源头是串口接收中断，再到命令处理函数，所以不能使用阻塞式的API
>
> <img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250508214217304.png" alt="image-20250508214217304" style="zoom:50%;" />
>
> <img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250508214449743.png" alt="image-20250508214449743" style="zoom:50%;" />

### 使用到的硬件

任务调度流程图，根据创建任务的大思路，一点点完善

从任务创建-到各个外设 ADC SPI  串口(printf重定向) 按键(长按，短按)，这里实现部分的hal层； 再实现那个打印一步一步 （蓝牙ble->串口usart2->处理ble->处理环形缓存区数据printer->发送打印头->驱动电机(前进，后退，几步，加热）；完成上报任务-need report，实现定时器；完成各个情况的led显示；最后完善任务task所有的初始化，任务创建，长按，短按的具体事件

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250508215211605.png" alt="image-20250508215211605" style="zoom:50%;" />

## 实现

### 我要干什么

1. 先把CUBEMX设置好
2. 添加各种文件--分类这几类文件是干什么的
3. 列举-完成各个外设--说明每个外设需要完成的函数功能是什么
4. 封装hal层，获取从外设读取来的状态，电量，文档，对led的设置
5. 完成打印这一套流程（蓝牙-->串口-->消息队列缓存区-->打印机头+驱动电机）
6. 各种状态，打印，电机运行，蓝牙；这些与串口的关系--打印语句；与led的关系进行显示；与按键的关系，开始或者停止打印，电机的前进或者后退
7. 定时器创建
8. 任务上报
9. led情况显示
10. 创建任务
11. task初始化总和
12. 调用task_Init

### CUBEMX

#### RCC--设置时钟

- 设置外部高速时钟HSE
- 设置HCLK 72MHZ
- 设置Debug方式支持Serial Wire

#### GPIO--控制外设

连接对应各个外设接口

- 按键BTN--PA4--输入模式 + 上拉电阻

----

- 打印机缺纸VHINT--PA8--外部中断模式 (低电平表示缺纸)
- 打印头电源升压控制引脚VH_EN--PA11--复用推挽输出--默认低
- 打印机数据锁存器LAT--PB1--复用推挽--上拉--默认低
- 通道选择器STB1-6--PA10--PA15--复用推挽输出--默认低---是用来控制通道开关--是否开启这个通道

----

- 灯LED--PB0--复用推挽--上拉--默认低电平

----

- 电机引脚MOTOR1-4--PB6--PB9--复用推挽--上电默认低电平

####ADC--测电量，温度

- 测电量--测电池的电量
- 温度，当前环境下的温度
- 设置多通道+连续模式+扫描模式
- 采样周期为239.5
- Rank1为通道1，Rank为通道2

#### TIM1--定时1US

RTOS中实现不了1us的定时，我们借助TIM1实现us级别定时。实现us_Delay()

- 选择时钟源：内部时钟
- 72 000 000/72 = 1000 000 hz
- 1us

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250511192050090.png" alt="image-20250511192050090" style="zoom:50%;" />

#### SPI--打印机通信

半双工主模式

半双工：一个时刻只能进行一个方向的传输，芯片作为主机

![image-20250511192419275](C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250511192419275.png)

分频系数选择4，分频系数越大，频率越小，传播得就越慢

#### 串口--printf+蓝牙接收

- USART1--串口--后续重定向实现printf
- USART2--与蓝牙通信
- 串口--异步通信
- 波特率都是115200 8 N 1，默认GPIO；既发送也接收；

#### 设置支持FreeRTOS

v1 v2都可

4072 好像影响不大

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250511200632574.png" alt="image-20250511200632574" style="zoom:50%;" />

#### TIM4--打印超时+状态上报

设置TIM4时钟源

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250511200753800.png" alt="image-20250511200753800" style="zoom:50%;" />

#### 设置

.c.h文件分开；

### 文件创建

对外设模块的创建	adc ble button motor printer spi 

获取状态函数，对hal层的创建	工具：device 封装：hal

对Freertos相关	timer task 

缓存区信号量管理：queue

对总配置相关	config

- 创建文件夹hal utils

### 系统设置

- 设置debug reset and run
- 加入新建的文件夹路径，并add进入项目

### 完成外设模块

前三个，不需要连接打印头

#### ADC--电量

- 测连接的电池的电量

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250512190525859.png" alt="image-20250512190525859" style="zoom:50%;" />

从 ADC 获得的原始数值（通常是一个 12 位的数字）转换为相应的电压值。具体来说，ADC 转换值范围是 0 到 4095（对于 12 位 ADC）

设置串口重定向，进行显示--阻塞，等待有数据时发送

> - 在GCC中，通常通过__io_putchar函数来实现输出
> - 在其它编译器中（如Keil或IAR）中，通常使用fputc来实现输出
> - 如下使用hal库层进行抽象，可以选择阻塞或者不阻塞

```c
#ifdef __GNUC__
  /* With GCC/RAISONANCE, small printf (option LD Linker->Libraries->Small printf
     set to 'Yes') calls __io_putchar() */
  #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
  #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif /* __GNUC__ */
/**
  * @brief  Retargets the C library printf function to the USART.
  * @param  None
  * @retval None
  */
PUTCHAR_PROTOTYPE
{
  /* Place your implementation of fputc here */
  /* e.g. write a character to the EVAL_COM1 and Loop until the end of transmission */
  HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);
 
  return ch;
}
```

task中实现创建任务，初始化，放在main中

1. 完成ADC初始化
2. ADC测量电量，温度
3. 进行平均值
4. 设置USART1串口重定向
5. 创建任务测试
6. 偏移计算
7. 电量映射

间断模式+扫描模式

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513101928259.png" alt="image-20250513101928259" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513101946481.png" alt="image-20250513101946481" style="zoom:50%;" />

暓%?*テ??ADC channel0 end value = ->2.048V 
 	ADC channel1 end value = ->3.298V 
 ADC channel0 end value = ->2.049V 
	 ADC channel1 end value = ->3.298V 
 ADC channel0 end value = ->2.049V 
 	ADC channel1 end value = ->3.298V 
 ADC channel0 end value = ->2.050V 
 	ADC channel1 end value = ->3.298V 

> 这个结果通道0的电量检测是没有问题的，因为这里选择了分压，IO口只能承受3.3V以内的电压
>
> 这个点实际上就是接近2.1V
>
> 多看.4外围驱动设计
>
> <img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250512233729360.png" alt="image-20250512233729360" style="zoom:50%;" />
>
> 看不懂或者不理解的地方去看视频的原理讲解

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250512233346217.png" alt="image-20250512233346217" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250512233355552.png" alt="image-20250512233355552" style="zoom:50%;" />

- 加转换成0-100的电量显示，范围在3.3--4.2之间
- 并且加入四舍五入，如果前面部分的值是93.7+0x5则会进位，如果为93.4+0.5则最后留下的整数不会进位

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513110552875.png" alt="image-20250513110552875" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513114012180.png" alt="image-20250513114012180" style="zoom:50%;" />

#### hal层--LED

led初始化熄灭，

根据不同的状态变化led

设置延时

在config配置文件里面引入关于Freertos的文件，就方便接下来所有的调用

```c
#include "em_hal.h"
#include "em_gpio.h"
#include "em_config.h"

void Hal_Init(void)
{
	digitalWrite(LED_GPIO_Port,LED_Pin,1);
}

void Run_Led(led_type_e type)
{
	switch(type)
	{
		case LED_CONNECT:
			digitalWrite(LED_GPIO_Port,LED_Pin,0);
			break;
		case LED_DISCONNECT:
			digitalWrite(LED_GPIO_Port,LED_Pin,1);
			break;
		case LED_WARN:
			digitalWrite(LED_GPIO_Port,LED_Pin,0);
			vTaskDelay(200);
			digitalWrite(LED_GPIO_Port,LED_Pin,1);
			vTaskDelay(200);
			digitalWrite(LED_GPIO_Port,LED_Pin,0);
			vTaskDelay(200);
			digitalWrite(LED_GPIO_Port,LED_Pin,1);
			vTaskDelay(200);
			break;
		case LED_PRINTER_START:
			digitalWrite(LED_GPIO_Port,LED_Pin,0);
			vTaskDelay(200);
			digitalWrite(LED_GPIO_Port,LED_Pin,1);
			vTaskDelay(200);
			break;
		case LED_BLE_INIT:
			digitalWrite(LED_GPIO_Port,LED_Pin,0);
			vTaskDelay(10);
			digitalWrite(LED_GPIO_Port,LED_Pin,1);
			vTaskDelay(10);
			break;
		default:
			break;
	}
}

```

#### 按键模块

按键定义：  超时时间，按键是否按下，是否在长按

`使用标志位的时候，true一定要对应false，开了一定要记得关`

函数：获取当前click时间，Init按键初始化，按键运行逻辑

> 按键按下消抖判断，置按下标志位
>
> 按键拾起，判断时间长短，长按--设置长按标志位结束，短按--继续短按逻辑。并且设置按下结束；按键没有拾起，长按超过1s，打印机继续走纸，设置正在长按。

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513124118949.png" alt="image-20250513124118949" style="zoom:50%;" />

关于cmsis_os.h这个文件

- 使用CMSIS_RTOS里面的API可以直接适配这两个操作系统

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513153717132.png" alt="image-20250513153717132" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513154033314.png" alt="image-20250513154033314" style="zoom:50%;" />

#### 按键运行逻辑

长按：电机一直运行

长按结束：电机停止

短按：启动通道测试程序

#### ADC--温度测量

这个温度是获取打印机头的温度

所以前面才一直获取的3.3v

公式中的 `1 / (log(Rt/Rp)/Bx + 1/T2)` 计算得到的是 **开尔文温度**，减去 `273.15` 后转换为摄氏度。

先获取阻值，再通过阻值作为参数计算出温度值

1. 获取温度：将ADC变成3.3-->计算阻值
2. 使用公式法计算

开尔文温度=实际温度+273.15；

```c
//公式法计算
float get_temp_calculate(float Rt)
{
	float temp = 0.0f;
	float Bx = 3950;
	float R7 = 30000;
	float T7 = 25+273.15;
	float Kt = 273.15;

	temp = 1/(log(Rt/R7)/Bx +1/T7)-Kt+0.5;
	return temp;
}

//获取温度
float get_adc_temperture(void)
{
	float temp = 0.0f;
	float Rt = 0;
	float vol = 0;
	vol = (float)ADC1_Value[1]*3.3f/4096;
	printf("ADC temperatrue analog value = %f\r\n",vol);
	
	Rt=(10000*vol)/(3.3f-vol);
	printf("ADC temperatrue Rt = %f\r\n",Rt);
	
	temp = get_temp_calculate(Rt);
	printf("ADC temperatrue temperture = %f°C\r\n",temp);
	
	return temp;
}
```

#### BLE蓝牙通信

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513211829333.png" alt="image-20250513211829333" style="zoom:50%;" />

>  **关于****BLE****服务（Service）、特征(Characteristic)、UUID？** 一般来说，蓝牙里面有多个Service，一个Service里面包括多个Characteristic。 一个蓝牙协议里面包含的Service和Characteristic是比较多的 ，那么这么多的同名属性用什么来区分呢？ 就是UUID，每个Service或者Characteristic都有一个 128 bit 的UUID来标识。

- 我们需要去定义服务UUID，定义特征UUID

`在em_config.h里面去定义UUID`

4.注册服务、特征回调函数，发布广播，在客户端连接后就可以通信

一旦是有客户端连接上，或者是它发数据给我们的时候，我们就通过这个回调函数，对这个数据进行一定的一个处理；注册完回调函数后，我们就去发布我们设备的一个广播，让周边的一个设备，可以通过扫描的方式，扫描到我们的一个

为什么通过蓝牙串口传透不需要使用蓝牙？

![image-20250513214417076](C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513214417076.png)

----

AT指令是单片机串口发送给其蓝牙模块的

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513215415622.png" alt="image-20250513215415622" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513215430978.png" alt="image-20250513215430978" style="zoom:50%;" />

单片机串口再接收从蓝牙模块传过来的数据，进行存储

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513215528702.png" alt="image-20250513215528702" style="zoom:53%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250513215549382.png" alt="image-20250513215549382" style="zoom:30%;" />

----

- **单片机串口接收蓝牙发送过来的数据**：重写串口接收回调函数
- `这个串口接收蓝牙数据，需要使用的中断接收，所以在main中就要开启接收中断`

```c
	HAL_UART_Receive_IT(&huart2,(uint8_t *)&aRxBuffer,1);
```

1. 在usart.c中重写串口2的接收回调函数，
2. 接收回调函数中放入一个命令处理函数，以及开启下一次的接收中断

- 当单片机串口想向蓝牙模块发送数据时，直接transmit即可

> 在别的文件中声明的全局变量，当我想使用时，使用extern可以拿过来使用

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250514104807257.png" alt="image-20250514104807257" style="zoom:50%;" />

----

**蓝牙模块命令处理函数具体实现** em_ble.c

> 这个文件处理发送给蓝牙模块的AT指令
>
> 处理从蓝牙模块接收的需要打印的数据

AT指令必须大写，并且以回车换行符结尾（CRLF）

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250514111922503.png" alt="image-20250514111922503" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250514110708053.png" alt="image-20250514110708053" style="zoom:50%;" />

----

先进行串口到蓝牙模式，AT指令的发送，同时设置当前蓝牙初始化过程的状态  ble_Init

- `strlen(ble_in_at_mode)` 是 C 标准库函数，用于计算字符串 `ble_in_at_mode` 的长度
- 超时时间设置为0xffff

`循环进行初始化，直到初始化完成`

初始化完成后，打印当前状态，并且让led响应

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250514112745388.png" alt="image-20250514112745388" style="zoom:50%;" />

逻辑：

进入蓝牙初始化

进入循环：

> 循环次数++
>
> 延时
>
> 根据当前模式转换
>
> 原代码只有当初始化完成时，才退出循环，其它情况都是一直在执行

---

处理接收的数据，写接收函数

填充数组内容及填充大小

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250514150559751.png" alt="image-20250514150559751" style="zoom:50%;" />

对于串口从蓝牙模块接收的数据，分为两种类型

一种是AT命令返回的语句，此时就是BLE初始化还没有完成时，正在AT模式里

一种是（此时BLE初始化完成）发来的CONNECT 和DISCONNECTED状态，以及需要传输到打印机里面的数据，需要保存到缓存区

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250514153959316.png" alt="image-20250514153959316" style="zoom:50%;" />

`它是一个字符一个字符构建起来的`

字符串就是字符数组！！！

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250514155958104.png" alt="image-20250514155958104" style="zoom:50%;" />

- 在BLE初始化完成后，清0
- 接收到CONNECTED DISCONNECTED时，缓存区清除要记得延时，不然后续数据可能被打断

```c
int cmd_index = 0;
uint8_t cmd_buffer[100];
bool need_clean_ble_status = false;

//处理接收的数据
void uart_cmd_handle(uint8_t data){
        cmd_buffer[cmd_index++] = data;//接收从中断中串口接收的数据
        char *ptr_char = (char*)cmd_buffer;//ptr_char被赋值为C的首地址
        if(g_ble_init_step == BLE_INIT_FINISH){//初始化完成之后处理数据
        										//检查这个子串当中包含的字符串是否有connected
												if(strstr(ptr_char, "CONNECTED") != NULL){
													need_clean_ble_status = true;//说明要清空这个缓存区数据
													run_led(LED_CONNECT);
												}
```

手机端发送0xA5 0xA5 0xA5 0xA5 0xnn类型的数据时，会把该数据当作颜色深度设置指令处理，0xnn为30，60，100，用于设置打印颜色深度。

接收处理打印深度，就是打印停留时间

手机端发送开始打印的指令为0xA6 0xA6 0xA6 0xA6 0x01，代表接收数据完成

接收了48个字节，就把数据放入缓存区

----

处理正在蓝牙初始化过程中的AT指令返回数据，进行蓝牙模式转换

返回类型 OK 名字 status

通过中断接收蓝牙返回的数据，可以改变当前设置的蓝牙状态，等FINISH之后，有机会跳出那个循环

为什么DISCONNECTED CONNECTED ERROR_DEVICE

要等200ms，因为这些设备状态获取广播需要间隔200ms进行等待，所以不能立马清空缓存区

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250514175150282.png" alt="image-20250514175150282" style="zoom:50%;" />

- 加入关于数据包的get set函数，加入设置当前蓝牙连接状态

搞不懂的地方就和原代码关键部分逐一分析对比！！！

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250515145801101.png" alt="image-20250515145801101" style="zoom:50%;" />

这个开启使用API的中断接收，你必须要开启NVIC，才能使用，所以之前才接收不到蓝牙回传的数据

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250515164821688.png" alt="image-20250515164821688" style="zoom:33%;" />

我想修改回之前的switch方法试一试--不改了

继续改代码

----

手机指令发送 0xa6 0xa6 0xa6 0xa6 0xa1 (即为开始打印的逻辑)

设备端收到0xA5 0xA5 0xA5 0xA5 0xnn类型的数据时，会把该数据当作颜色深度设置指令处理

#### 打印头缺纸检测

开启PA8缺纸检测GPIO外部中断

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250515165001945.png" alt="image-20250515165001945" style="zoom:30%;" />

```c
GPIO_Pin & GPIO_PIN_8 //用于判断 GPIO_Pin 中是否启用了引脚8
//判断触发的引脚是哪一个
```

#### 封装hal层,设置device

对于当前的温度，电量，打印机是否缺纸，进行状态的一个封装

一个结构体封装所有的当前状态，进行Get set

五个读取当前状态的函数

- 根据获取的温度，电量，打印机是否缺纸，打印数据是否接受完成，当前打印状态；进行Set
- 当蓝牙连接成功，遇到一些状态的时候，就进行上报ble_report

----

- 设置device，进行状态结构体的设置；
- device.c 设置set函数在hal当中调用

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250515173434869.png" alt="image-20250515173434869" style="zoom:50%;" />

----

```c
device_state_t* get_device_state(void)
{
	return &g_device_state;//返回当前结构体指针
}
```

----

#### 步进电机驱动

实现：初始化，开始，运行，停止；按指定步数运行

初始化，四个位置都置0

让它走8步打印一行，设置2ms进行移动，方便加热

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250515215111175.png" alt="image-20250515215111175" style="zoom:50%;" />

#### 打印模块

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250515215044265.png" alt="image-20250515215044265" style="zoom:50%;" />

##### 创建定时器，设置每2ms移动8步走一行

1. 引入timers.h
2. 加入关于定时器的宏定义

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250516123752715.png" alt="image-20250516123752715" style="zoom:50%;" />

----

> 打印机的原理是逐行打印，具体为打印一行后，电机拖动纸张前移一行，然后接着打印第二行，再前移，重复直至内容打印完成。

看完知识视频，测试一下这个步进电机驱动，然后实现消息队列，

##### 回去测试

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250516195651685.png" alt="image-20250516195651685" style="zoom:50%;" />

#### 定时器设置

--利用tim1定时

```c
#include "tim.h"
#define DLY_TIM_Handle (&htim1)  // Timer handle

#define hal_delay_us(nus) do { \
    __HAL_TIM_SET_COUNTER(DLY_TIM_Handle, 0); \
    __HAL_TIM_ENABLE(DLY_TIM_Handle); \
    while (__HAL_TIM_GET_COUNTER(DLY_TIM_Handle) < (nus)); \
    __HAL_TIM_DISABLE(DLY_TIM_Handle); \
} while(0)
```
这是一个核心的宏定义，名为 hal_delay_us，它实现了一个基于硬件定时器的微秒级延时。

nus: 这是宏的参数，代表需要延时的微秒数 (number of microseconds)。

do { ... } while(0): 这是一个常用的C语言技巧，用于将多行语句封装成一个单一的、行为类似函数的宏，可以安全地用在 if-else 等语句中，并要求调用时使用分号。

__HAL_TIM_SET_COUNTER(DLY_TIM_Handle, 0);: 将 DLY_TIM_Handle (即 htim1) 所指向的定时器的计数器值设置为0。这是延时的起点。

__HAL_TIM_ENABLE(DLY_TIM_Handle);: 启动定时器。

while (__HAL_TIM_GET_COUNTER(DLY_TIM_Handle) < (nus));: `这是一个 忙等待 (busy-wait) 循环。CPU会一直在这里循环，不断地读取定时器的当前计数值，直到计数值达到或超过 nus。`

重要：这个宏的精确度依赖于定时器 htim1 的时钟频率和预分频器（prescaler）的配置。通常配置成定时器每计数一次代表1微秒。

__HAL_TIM_DISABLE(DLY_TIM_Handle);: `当延时时间到达后，禁用定时器。`

总结：`这个宏提供了一个阻塞式的微秒延时`。**在延时期间，CPU会持续检查定时器，不能执行其他任务（除非发生中断）。**

----

#### 打印头电源模块

VH引脚是打印头的一个加热的引脚，这个端的引脚，它的电流是特别大的

> 就是一个打印头上面会有384个点，是由6个打印通道去控制的，就每一个通道可以控制48个点，最好是一个通道一个通道去控制，他在每一瞬间就只能最多打印64个点，那这一个VH的电流的话，就会相对来说小一点。

数据通过DI按CLK的时钟频率传入进来，我们不会马上发过去打印，而是先存入LAT 锁存寄存器，通过这个锁存引脚把它保存住；等到所以的数据发送完了，再放入（选择某一个通道）通道输出

> DI要先发进来，等这个锁存的引脚锁存之后，才能发出去；所以这个锁存的引脚也需要去添加output的一个控制

因为是384个bit，所以要发48个字节过去

这个VH需要7.2V的电压，目前没有，所以需要去加一个升压电路，把低电压转为高电压

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250516134014786.png" alt="image-20250516134014786" style="zoom:50%;" />

#### 完善ble上报功能

```c
void ble_report(void)
{
	if(get_ble_connect())//当蓝牙连接成功时，通过usart2上报给蓝牙，蓝牙发给手机
	{
		device_state_t* pdevice = get_device_state();//获取当前设备状态
		uint8_t status[4];
		status[0] = pdevice->battery;
		status[1] = pdevice->temperture;
		status[2] = pdevice->papre_state;
		status[3] = pdevice->printer_state;
		//这个数组本来就可以指向首地址吧
		HAL_UART_Transmit(&huart2,(uint8_t*)status,sizeof(status),0xffff);
	}
}
```

#### 完成按键运行逻辑

长按：电机一直运行

长按结束：电机停止

短按：启动通道测试程序；所以要有一个标志位，来进行判断

- 这里逻辑是对电机的驱动，可以顺便用来测试

`打开按钮运行，即可检查，电机能否正确运行`

可以运行，但是只能转动一次

delete之后它会存有一个旧的无效地址

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250517114256580.png" alt="image-20250517114256580" style="zoom:50%;" />

#### 消息队列

##### 加入SPI模块

使用SPI通信给打印机发送数据

##### 消息队列

所以我们的做法是把接收的数据写入消息队列中，需要打印再进行读取。

自己写了个缓存区，实现对打印数据的存储

- 功能：实现`对缓存区数据的读入，以及写入`；
- 使用`结构体管理`，读取index，写入index；以及当前行数left-line
- 对缓存区数据进行`信号量管理`，保证数据统一
- `缓存区数据初始化`
- `get函数`获取当前所拥有行数

> 使用互斥量，要引入#include "semphr.h"
>
> ！！！

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250517132659763.png" alt="image-20250517132659763" style="zoom: 33%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250517134453323.png" alt="image-20250517134453323" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250517134459025.png" alt="image-20250517134459025" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250517135509636.png" alt="image-20250517135509636" style="zoom:50%;" />

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250517135919188.png" alt="image-20250517135919188" style="zoom:50%;" />

- 任何一个成功的take，也只要一个give执行

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250517140955634.png" alt="image-20250517140955634" style="zoom:50%;" />

##### bug

```c
/**
  * @brief 写入一行数据
  * @param  
  * @retval 
  */
void Write_to_buffer(uint8_t *pdata,size_t length)
{
	//判断是否有更高优先级的任务需要调度
	static BaseType_t xHigherPriorityTaskWoken;
	if(length==0)
	{
		return;
	}
	if(ble_rw_tdef.left_line==MAX_LINE) return;
	if(length>MAX_ONELINE_BYTE) length = MAX_ONELINE_BYTE;
	
	if(xSemaphoreTakeFromISR(xSemaphore,&xHigherPriorityTaskWoken)==pdTRUE)//pdPASS
	{
		//这是 C 标准库中的内存复制函数，用于将一段内存的数据复制到另一段内存
    //目标内存地址，复制数据，长度
    memcpy(&ble_rw_tdef.printer_buffer[ble_rw_tdef.w_index], pdata, length);
		ble_rw_tdef.w_index++;
		ble_rw_tdef.left_line++;
		if(ble_rw_tdef.w_index>=MAX_LINE){
			ble_rw_tdef.w_index = 0;//应该回到0
		}
		if(ble_rw_tdef.left_line>=MAX_LINE){
			ble_rw_tdef.left_line = MAX_LINE;
		}
		xSemaphoreGiveFromISR(xSemaphore,&xHigherPriorityTaskWoken);
	}
	// else {
    // 如果 xSemaphoreTakeFromISR 失败, 它会立即返回 pdFAIL,
    // 这种情况下，信号量没有被获取，因此也不需要释放。
    // 函数会直接跳到下面的 if(xHigherPriorityTaskWoken == pdTRUE)
    // }
	
	if(xHigherPriorityTaskWoken==pdTRUE)
	{
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

/**
  * @brief 读出一行数据
  * @param  
  * @retval 
  */
uint8_t* read_from_buffer(void)
{
	uint32_t index = 0;
	// 查看是否可以获得信号量，如果信号量不可用，则用10个时钟滴答来查看信号量是否可用
	if (xSemaphoreTake(xSemaphore, (portTickType)10) == pdPASS)
	{
		if(ble_rw_tdef.left_line>0)
		{
			ble_rw_tdef.left_line--;
			index = ble_rw_tdef.r_index;
			ble_rw_tdef.r_index++;
			if(ble_rw_tdef.r_index>=MAX_LINE){//!!!这里忘记>=
				ble_rw_tdef.r_index=0;	//归0
			}
			xSemaphoreGive(xSemaphore);	
			return ble_rw_tdef.printer_buffer[index].buffer;
		}
		xSemaphoreGive(xSemaphore);	
		return NULL;
	}else
		printf("take fail\n");
		return NULL;
}
```

#### 定时器

- 这里突然出现空间不足的问题，修改configTOTAL_HEAP_SIZE变小一点
- 定义分配给 RTOS 内核用于动态内存分配的总堆空间大小（以字节为单位）。

间隔10s上报设备状态到手机--设置为周期性计时，打印时如果持续加热20s---设计为单次计时，需要触发报警

创建定时器

设计每个定时器的回调函数，

设置标志位判断是否在定时函数期间，

清除标志位函数，获取标志位函数

#### printer

驱动打印头进行打印测试

打印和电机驱动是一体的，所以在初始化打印机的时候顺便初始化电机

初始化打印机：设置VH为low，失能所以STB通道。初始化motor，初始化spi，打印要用到SPI发送数据

---

`SPI发送数据，LAT高电平拉低，将数据发送出去`

LAT从低拉高1us

这个打印机是热敏打印，这个VH是加大电压电流进行驱动的，这个STB是真正进行加热，让打印纸变黑的

STB 0就不加热，1就加热

打印完成之后，就 控制移动

----

- 打印加热延时

> 【根据输入的2600us+根据输入数据计算的加热时间（根据每个通道需要加热的点数和）+加上手动偏移】*全局加热英子
>
> **理论总加热时间：2.0ms**（基于分时激活6组选通）

<img src="C:\Users\86178\Desktop\projec_qrs\智能蓝牙打印机\assets\image-20250517213437204.png" alt="image-20250517213437204" style="zoom:50%;" />

----

STB通道不同时启用，轮流启用，就是等所有STB启用过之后，就是这一行加热打印完了，再进行驱动电机移动

电机运行是8步走一圈，所以保证每次走四步（就是一行），绕完一圈，再从0开始，

8步就是两行，只是电机是8步一圈，所以这样循环更好更流畅

然后一行其实很短，保证加热的时候同时走纸减少卡顿

打印：打印准备初始化，打印开始初始化，打印密度设置，打印停止，清空计算的加热点数，发送一行数据；各通道打印（加热）；移动电机并加热；打印错误检查加是否上报；可变队列打印，数组打印，单通道数组打印，通道测试

#### task

定时器内存不足，改成静态chaung'j

## 总结

我发现我之前一直打印不清晰的原因是，在usart2的接收回调处理数据的uart_cmd_handle里面加了会循环打印的printf，而且printf是通过串口1来进行转换打印的，导致数据混乱不清晰

**避免在高速数据处理回调/中断中使用 printf**

> 您好！这是一个非常关键的发现，也完全解释了为什么之前打印会出现“不清晰”甚至数据丢失的问题！
>
> 您指出的核心问题是：**在处理蓝牙数据（USART2）的 `uart_cmd_handle` 函数中，使用了 `printf` 将调试信息通过串口1（USART1）输出。**
>
> 这会导致以下几个严重的问题，从而造成您所说的“数据混乱不清晰”：
>
> 1. **`printf` 的阻塞特性和耗时：**
>    - `printf` 函数（尤其是在嵌入式系统中通过UART输出时）通常是**阻塞的**。这意味着当 `printf` 通过USART1发送数据时，CPU会等待发送完成（或者至少是数据被移入发送缓冲区）。
>    - 如果在USART2快速接收蓝牙数据的同时，`uart_cmd_handle` 内部频繁调用 `printf` 往USART1打印，CPU会花费大量时间在处理USART1的输出上。
> 2. **影响USART2的数据接收：**
>    - 当CPU忙于通过USART1执行 `printf` 时，它可能无法及时响应USART2的接收中断或处理已接收到的数据。
>    - 如果蓝牙模块持续高速发送数据，而 `uart_cmd_handle` 因为内部的 `printf` 而执行缓慢，USART2的硬件接收缓冲区很容易溢出，导致**蓝牙数据丢失**。这直接解释了为什么打印会不完整或“不清晰”。
> 3. **任务/中断优先级和调度问题：**
>    - 如果 `uart_cmd_handle` 是在某个中断服务程序（ISR）的上下文中被直接或间接调用的，或者在一个较高优先级的任务中，长时间的 `printf` 会严重阻塞该中断/任务，进而影响系统中其他任务的实时性和响应。
>    - 如果 `uart_cmd_handle` 本身不是在中断上下文中，但它处理的数据来源于中断（例如，USART2接收中断将数据放入一个缓冲区，`uart_cmd_handle` 从该缓冲区读取），那么 `printf` 造成的处理延迟仍然会导致该缓冲区的溢出。
> 4. **USART1输出的混乱：**
>    - 如果您原本期望USART1主要用于输出其他任务的日志或系统状态，那么 `uart_cmd_handle` 中插入的 `printf` 会将蓝牙数据处理过程中的调试信息也混入USART1的输出流中。这使得通过USART1观察系统状态变得困难和混乱，因为不同来源的信息交织在一起。
>
> **这与我们之前的分析非常吻合：**
>
> - 我们之前观察到，日志打印较少的C版本代码“打印的很好”。您的这个发现完美地解释了这一点：**减少了 `uart_cmd_handle` 内部通过USART1的 `printf` 调用，从而显著减少了对蓝牙数据接收（USART2）的干扰，也减少了USART1输出流的混乱。**
> - 那些有“大量日志打印”的版本，正是因为这些额外的 `printf` 调用（通过USART1），导致了性能瓶颈和数据处理冲突。
>
> **解决方案和最佳实践：**
>
> 1. **避免在高速数据处理回调/中断中使用 `printf`：** 这是嵌入式开发中的一个重要原则。`uart_cmd_handle` 这种直接处理输入数据流的函数，应该尽可能快地执行完毕。
> 2. **使用轻量级日志方法：**
>    - **标志位（Flags）：** 在 `uart_cmd_handle` 中设置标志位，由一个较低优先级的任务来检查这些标志位并执行 `printf`。
>    - **环形缓冲区（Ring Buffer）：** 将需要记录的简短信息或事件代码快速存入一个内存环形缓冲区，由另一个任务专门负责从该缓冲区读取并格式化输出到USART1。
>    - **调试引脚（Debug Pins）：** 通过操作GPIO引脚的状态来指示代码执行到了某个点，可以用逻辑分析仪观察。
> 3. **有条件编译日志：** 使用 `#ifdef DEBUG` 之类的宏来包裹调试用的 `printf` 语句，这样在发布版本中可以轻易地将它们全部移除，避免对性能的影响。
>
> 您能定位到这个问题的根本原因非常棒！这通常是嵌入式系统中比较棘手难以发现的问题之一，因为它涉及到不同外设、中断和任务之间的时序与交互。解决了这个问题，系统的稳定性和数据处理的可靠性会得到极大的提升。
